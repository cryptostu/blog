#挖矿难度精讲
##挖矿难度

比特币主链上，平均每十分钟主链就增加一个块。随着数字货币的发展，参与的miner数量与日俱增，挖矿技术日新月异，全网的算力也是以惊人的速度增长。BCT中为了保证平均主链的高度增加的速度依然维持最初设定，实现来挖矿难度调整的功能。深入理解挖矿难度的概念以及挖矿难度调整的方案对开发人员以及miner都很重要，因为挖矿难度设置不合理可能会导致全网出块速度极不稳定甚至货币超发。本文将详细介绍BTC&BCH挖矿难度相关知识，主要涉及到：块结构分析，Pow算法，挖矿难度的表示及调整的方案。

####1. 块

BTC系统中，mimer维护了一个mempool，当miner接收到新的交易信息之后，首先会经过严密的核验，通过核验的交易将会放入mempool。挖矿就是把mempool里的交易打包成块，并加到主链上。
当miner开始新一轮打包之后，首先会创建一个空的块，块结构分为*块头*以及*块信息*两部分。然后先打包块信息，再根据块信息填充块头。

下图是写本文稿时截取最新的BCH block详情。

![](https://ws1.sinaimg.cn/large/007egaxyly1fx1mn0z848j318214sqc1.jpg)


**块信息**存放的是从mempool里取出来的一系列交易信息，值得注意的是：第一条交易信息一定是Coinbase交易，每一个块的高度信息存在Coinbase交易的input里的coinbase data字段中。

Coinbase 交易input的结构如下：
![](https://ws1.sinaimg.cn/large/007egaxyly1fx1mfjp2y1j30m2094abd.jpg)

值得注意的是，Coinbase交易中没有unlocking script。取而代之的是coinbase data字段。该字段数据长度可变，从2-byte～100-byte，包含了很多信息：对于每个v2版的块最高两位表示用于表示块高度的数据段的字节数；最高第三位开始就是小端法表示的块高度数据(例如：coinbase data为0x03443b04...，则块高度用16进制表示为0x043b44，十进制为277316);
extra nonce作为中间字段；（最低字段为ASCII编码的字符串，用于表示mining ，是否支持P2SH，不过目前已经弃用了）；Transaction Hash里全部填充的是“0”；sequence number设置为0xFFFFFFFF，使LockTime无效。

在交易信息聚合完毕之后，接下来创建区块头。块头结构如下：![](https://ws1.sinaimg.cn/large/007egaxyly1fwzmlxfbncj31e00kk43u.jpg)

区块头80-byte，一共6个字段：
1. 版本号
2. 前一个块的hash值，不可以改变
3. MerkleRoot的hash值，用于存块信息里的交易的Merkle Tree的root节点的值，可以改变（改变coinbase中input中的值）
4. 时间戳，可以改变（可以基于MTP11进行调整）
5. nonce，随机值用于PoW算法，可以改变
6. nBit，PoW算法结果必须小于这个数才能“win”，同一个高度的块相同，不同高度的块可能不相同。值由共识算法确定，miner不能改

####2.PoW算法
>PoW（*Proof-of-Work*）算法工作量证明（Proof-of-Work，PoW）是一种对应服务与资源滥用、或是阻断服务攻击的经济对策。一般是要求用户进行一些耗时适当的复杂运算，并且答案能被服务方快速验算，以此耗用的时间、设备与能源做为担保成本，以确保服务与资源是被真正的需求所使用。


该算法具有：去中心化，单向，避免碰撞，目标难度易调整，安全等特点，所以现在包括BTC，BCH在内的很多币种都采用PoW共识机制。

从实现上来说：
PoW算法的输入任意长度，输出为固定长度，比如通常使用SHA256算法对应输出256-bit。miner用PoW算法计算整个块头的hash值，所以块头任意一位发生变化，得到的hash值会变得完全不一样，而且大小变化方向不确定。基于此，我们比较hash值是否小于current_target值。如果是，则广播这个区块；如果不是，则再随机选择一个nonce值，然后再次计算块头hash值。重复以上动作。

由此可知，target越小，越小概率满足挖矿要求，所以挖矿难度更大。
####3.挖矿难度及难度调整
挖矿难度的描述可以认为有三种形式，difficulty（难度值，浮点数），current_target（当前目标值，256-bit），nbits（32-bit）。

**难度值** 不写在区块中，而是以浮点数的形式给人直观的感受难度程度。
`difficulty = difficulty_1 / current_target；`
difficulty_1为常数：`0x00000000ffff0000000000000000000000000000000000000000000000000000`
创世块的 current_target = 0x00000000ffff0000000000000000000000000000000000000000000000000000，所以创世块的difficulty = 1.0。

**nbits** 就是区块头nBits字段的值。可以理解它为“压缩”后的current_target。在计算current_target时，我们先转换为二进制然后用公式（a）来计算256-bit的current_target。

```
-------------------------------------------------
|   Exponent     |    Sign    |    Mantissa     |
-------------------------------------------------
| 8 bits [31-24] | 1 bit [23] | 23 bits [22-00] |
-------------------------------------------------

```
> This compact form is only used in bitcoin to encode unsigned 256-bit numbers which represent difficulty targets, thus there really is not a need for a
sign bit, but it is implemented here to stay consistent with bitcoind.

计算current_target的公式为：（值得注意的是：current_target 是一个无符号256-bit的值，之所以设置一个Sign字段，是为了与bitcoind代码保持一致）

$current_target =  Mantissa * 2 ^ {(8 * (Exponent - 3))}$                 (a)

根据公式计算之前截取的块信息的挖矿难度，nBits = 0x180192d4 所以 Exponent = 0x18，Mantissa = 0x192d4，根据公式可以算出：

current_target = 0x00000000000000000192d4000000000000000000000000000000000000000000

相较于创世块，current_target减小了大约 1/$2^{36}$ 倍，difficulty增加了大约 7184404942701倍。

为了维持平均每十分钟生成一个块的频率，BTC中current_target设计为了一个动态值，current_target根据全网算力的改变而做一些相应的调整，这就是**挖矿难度调整**。

在BTC中，挖矿难度调整方案为：每隔2016个区块时全网均会自动统计过去2016个区块生成耗时，重新计算出下一个2016个区块的目标值。除此之外，BTC限制了调整步长，即每次current_target最多增加或减少4倍。

> 新目标值= 当前目标值 * 实际2016个区块出块时间 / 理论2016个区块出块时间(2周)。

计算过程，Go代码如下:
```

func CalculateNextWorkTarget(prev2016block, lastBlock Block) *big.Int {
    // 如果新区块(+1)不是2016的整数倍，则不需要更新，仍然是最后一个区块的 bits
    if (lastBlock.Head.Height+1)%2016 != 0 {
        return CompactToBig(lastBlock.Head.Bits)
    }
    // 计算 2016个区块出块时间
    actualTimespan := lastBlock.Head.Timestamp.Sub(prev2016block.Head.Timestamp)
    if actualTimespan < powTargetTimespan/4 {
        actualTimespan = powTargetTimespan / 4
    } else if actualTimespan > powTargetTimespan*4 {
        // 如果超过8周，则按8周计算
        actualTimespan = powTargetTimespan * 4
    }
    lastTarget := CompactToBig(lastBlock.Head.Bits)
    // 计算公式： target = lastTarget * actualTime / expectTime
    newTarget := new(big.Int).Mul(lastTarget, big.NewInt(int64(actualTimespan.Seconds())))
    newTarget.Div(newTarget, big.NewInt(int64(powTargetTimespan.Seconds())))
    //超过最多难度，则重置
    if newTarget.Cmp(mainPowLimit) > 0 {
        newTarget.Set(mainPowLimit)
    }
    return newTarget
}
```
1. 判断是否需要更新目标值( 2016的整数倍)，如果不是则继续使用最后一个区块的目标值
2. 如果用时低于半周，则按半周计算。防止难度增加4倍以上。
3. 如果用时高于8周，则按8周计算。防止难度降低到4倍以下。
4. 用时乘以当前难度，再除以2周
5. 如果超过最大难度限制，则按最大难度处理

####4. BCH难度调整
BCH 诞生于区块高度 478558，相较于 BTC，BCH 移除了隔离见证并将区块大小目前也扩大至 32MB。由于两条链都采用PoW共识算法，而且都是10分钟生成一个块，但由于BTC全网算力比BCH的大很多，当BTC中一部分miner同时切入/切出到BCH挖矿系统，BCH的算力会迅速增加/减少，倘若继续沿用BTC的挖矿难度调整方案，BCH的出块难易程度将非常难把控。所以BCH启用新的难度调整方案。

BCH的难度值调整算法存在两种，紧急难度调整规则（EDA）和难度调整规则（DAA）（优先级更高）。


- **紧急难度调整规则（EDA）**

EDA是在沿用BCH的基础上，增加了一个Emergency Difficulty Adjustment处理方案。它的具体逻辑是：对于高度为2016倍数的就拿到此高度前2016块的blocktime，做BTC难度值调整；对于高度非2016倍数的块，则计算生成前六块的块总共耗时是否超过12h，如果超过则降低挖矿难度20%（在测试网中，如果当前块和上一个块blocktime超过20min，则将难度调整为最小1）。
```
func (b *BlockChain) getNextEDAWorkRequired(prevBlock *blockNode,
	header *wire.BlockHeader) (uint32, error) {

	// 如果块高度为2016整数倍，拿到此高度前2016块的blocktime，做BTC难度值调整；
	curHeight := prevBlock.height + 1
	if int64(curHeight)%b.chainParams.DifficultyAdjustmentInterval() == 0 &&
		int64(curHeight) >= b.chainParams.DifficultyAdjustmentInterval() {
		// Go back by what we want to be 14 days worth of blocks
		firstHeight := curHeight - int32(b.chainParams.DifficultyAdjustmentInterval())
		firstNode := b.bestChain.NodeByHeight(firstHeight)

		return b.calculateNextWorkRequired(prevBlock, firstNode.timestamp)
	}

	proofOfWorkLimit := b.chainParams.PowLimitBits
	if b.chainParams.ReduceMinDifficulty {
		// 测试网络中,如果当前块和上一个块blocktime超过20min，则将难度调整为最小1；
		if int64(header.Timestamp.Second()) >
			prevBlock.timestamp+2*int64(b.chainParams.TargetTimePerBlock.Seconds()) {
			return proofOfWorkLimit, nil
		}

		// Return the last non-special-min-difficulty-rules-block
		node := prevBlock
		for node.parent != nil &&
			int64(node.height)%b.chainParams.DifficultyAdjustmentInterval() != 0 &&
			node.bits == proofOfWorkLimit {
			node = node.parent
		}

		return node.bits, nil
	}

	// We can't go bellow the minimum, so early bail.
	bits := prevBlock.bits
	if bits == proofOfWorkLimit {
		return proofOfWorkLimit, nil
	}

	// If producing the last 6 block took less than 12h, we keep the same
	// difficulty
	node6 := b.bestChain.NodeByHeight(curHeight - 7)
	if node6 == nil {
		panic("the block Index should not equal nil")
	}
	mtp6Blocks := prevBlock.CalcPastMedianTime().Unix() - node6.CalcPastMedianTime().Unix()
	if mtp6Blocks < 12*3600 {
		return bits, nil
	}

	// 如果当前区块父块的MTP11时间和第（父块-6）区块的MTP11时间相差12个小时，则将当前区块难度降低20%；为了保证HashRate不会急剧下降。
  // MTP11时间是11个块按照blocktime排序后的中间时间；
  // 实际上发生这种情况时，难度并不会马上调整，而是等后面检测到时，也就是一般会推迟几个块，才开始紧急调整难度

	pow := CompactToBig(bits)
	pow.Add(pow, new(big.Int).Div(pow, big.NewInt(4)))

	// Make sure we do not go bellow allowed values.
	powLimit := CompactToBig(b.chainParams.PowLimitBits)
	if pow.Cmp(powLimit) > 0 {
		pow = powLimit
	}

	return BigToCompact(pow), nil
}
```

- **难度调整规则（DAA）**

由于EDA存在会导致一下结果：
1）出块速度极不稳定
2）算力波动剧烈
3）BCH超发等弊端，所以社区一直有新的提议关于优化BCH挖矿难度调整方案
在得到几大矿池的稳定算力支持后，bch开发团队为了解决以上几个问题，决定使用Amaury Sechet提出的DAA方案。其实现逻辑如下：
1. 新算法将在高度504031开始生效
2. 假设需要得到target_height的目标难度
3. (prevBlock - 1）至 (prevBlock - 1 - 2 ）这三块的ntime，排序，取ntime在中间的那块为lastNode
4. 取（prevBlock - 1 - 144）至 （prevBlock - 1 - 144 - 2）这三块的ntime，排序，取ntime在中间的那块为firstNode
备注：bch的目标是10分钟产生一块，一天产生144块
5. 区块上会纪录一个当前累计工作量（ChainWork），通过：
work =  10 * 60 * ( indexLast.ChainWork — indexFirst.ChainWork) /  actualTimeSpan 可以得出当前10分钟的算力值work
6. 再通过算力值得出目标难度。


具体实现代码如下：


```
func (b *BlockChain) getNextCashWorkRequired(prevBlock *blockNode,
	header *wire.BlockHeader) (uint32, error) {

	// 测试网络中,如果当前块和上一个块blocktime超过20min，则将难度调整为最小1;
	if b.chainParams.ReduceMinDifficulty &&
		(header.Timestamp.Unix() >
			(prevBlock.timestamp + int64(2*b.chainParams.TargetTimePerBlock.Seconds()))) {
		return b.chainParams.PowLimitBits, nil
	}

	// (prevBlock - 1）至 (prevBlock - 1 - 2 ）这三块的ntime，排序，取ntime在中间的那块为lastNode
	lastNode := b.getSuitableBlock(prevBlock)

	// 取（prevBlock - 1 - 144）至 （prevBlock - 1 - 144 - 2）这三块的ntime，排序，取ntime在中间的那块为firstNode
	firstHeight := prevBlock.height - 144
	firstNode := b.getSuitableBlock(b.bestChain.NodeByHeight(firstHeight))
	if firstNode == nil {
		panic("the firstNode should not equal nil")
	}

	//通过：work =  10 * 60 * ( indexLast.ChainWork — indexFirst.ChainWork) /  actualTimeSpan 可以得出当前10分钟的算力值work
	nextTarget := b.computeTarget(firstNode, lastNode)
	if nextTarget.Cmp(b.chainParams.PowLimit) > 0 {
		return b.chainParams.PowLimitBits, nil
	}

	return BigToCompact(nextTarget), nil
}

```
计算新Target方法如下：

```
func (b *BlockChain) computeTarget(indexFirst, indexLast *blockNode) *big.Int {
	if indexLast.height <= indexFirst.height {
		panic("indexLast height should be greater than indexFirst height ")
	}

	/**
	* From the total work done and the time it took to produce that much work,
	* we can deduce how much work we expect to be produced in the targeted time
	* between blocks.
	 */
	work := new(big.Int).Sub(indexLast.workSum, indexFirst.workSum)
	work.Mul(work, big.NewInt(int64(b.chainParams.TargetTimePerBlock.Seconds())))

	// In order to avoid difficulty cliffs, we bound the amplitude of the
	// adjustment we are going to do.
	if indexLast.timestamp <= indexFirst.timestamp {
		panic("indexLast time should greater than indexFirst time ")
	}
	actualTimeSpan := indexLast.timestamp - indexFirst.timestamp
	interval := int64(b.chainParams.TargetTimePerBlock.Seconds())
	if actualTimeSpan > 288*interval {
		actualTimeSpan = 288 * interval
	} else if actualTimeSpan < 72*interval {
		actualTimeSpan = 72 * interval
	}

	work.Div(work, big.NewInt(actualTimeSpan))
	/**
	 * We need to compute T = (2^256 / W) - 1 but 2^256 doesn't fit in 256 bits.
	 * By expressing 1 as W / W, we get (2^256 - W) / W, and we can compute
	 * 2^256 - W as the complement of W.
	 */
	return new(big.Int).Sub(new(big.Int).Div(oneLsh256, work), big.NewInt(1))
}

```

总结下来，DAA算法具有以下特性：
- 基于当前10mins的算力来设置挖矿难度；
- DAA在全网算力陡增，陡降情景中能及时调整挖矿难度，即使在全网算力突变的情况下，也能保证公平性；
- 避免当前算力与目标难度的不匹配导致的抖动；
- 可以一定程度上减少timestamp manipulation等攻击的影响。


2017年11月1日，ABC 将难度调整规则（DAA）加入了共识机制中。
####5.extra nonce解决方案
目前，BTC挖矿难度设置到了0x00000000000000000192d4000000000000000000000000000000000000000000。也就是说随机选取的数满足target的概率是$1/（2^{80}）$，但是块头的nonce字段只有4bytes，也就是32位，有可能$2^{32}$ 个随机数都试完来仍然找不到满足target的hash值。
所以上文区块头部分介绍的时候，最后补充都有字段是否可以改变的描述。额外解释一下，虽然coinbase在块信息里，但是它任何改变都会影响到hashMerkleRoot的取值发生改变，从而改变PoW的运算结果。仅仅coinbase里可以提供作为extra nonce的数据最多可达100bytes，800bits。
