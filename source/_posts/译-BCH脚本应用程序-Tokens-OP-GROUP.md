---
title: '[译]BCH脚本应用程序:Tokens(OP_GROUP)'
date: 2018-02-17 21:18:32
tags:
---

![bitcoin cash](http://upload-images.jianshu.io/upload_images/22188-7ff6ffc22ad7ac79.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

具有代表性的货币是用于任何没有内在价值但可以交换定义数量的商品（通常是黄金或白银）的代币的术语。 本节将讨论如何使用 satoshis 作为代表性货币，更一般地说，使用satoshis来代表所有权 - 例如股票，债券，实物，其他加密货币和“ICO”（初始货币产品） 被比特币社区命名为“彩色货币”。

我相信，以太坊最近的成功不是由复杂的合同（有一个问题是真正的，实际的合同是否会在区块链中有用），而是建立ICOs（初始货币产品）。对于那些怀疑的人来说， 代币的价值在实践中已经得到证实。

但是，在比特币现金区块链中创建代币的能力，如果做得适当，可以让代币利用比特币的所有基本功能（无权限，不可靠，不存在第三方，伪匿名等），所有的脚本功能以及代表 tokens 与 Bitcoin Cash 和其他代币任意交换。

将所有代表资金放在比特币现金区块链（而不是每个区块链中）的关键理由是bch 和代表币种的任何组合之间的原子，不可信，无权限，伪匿名交换。 此功能将比特币现金从“电子支付系统”（如比特币白皮书中所述）变成“电子交换系统”。

电子交换系统的一个非常有趣的功能是伪匿名交换。 在具有代币的比特币现金中，可以使用“半交易”来实现。 本质上来说，一个半交易是一组不平衡的输入和输出。 例如，参与者（“制造者”）可以选择以 200 个“红色”标记的输入和 100个“蓝色”的标记的一个输入进行部分交易。 另一个参与者（“接受者”）可以通过附加 100 个“蓝色”标记和 200 个“红色”标记的输入（可能是最终的BCH输入和输出）来选择“接受” 作为交易费用和变化）。 由于输入数量等于输出数量，现在构成了有效的交易，因此可以提交到区块链。

虽然上述交换有许多缺点，例如“制造商”的收购难度很大，但由于它构成了一种特殊的，不受信任的，匿名的，无权限的对等交换机制。 然而请注意，执法机构仍然需要在代币和真实商品之间的界限上进行识别 - 也就是说，当一个人试图将代币兑换为基础商品时，可能需要识别身份。

另一个重要的特征是代表tokens和比特币现金之间地址的共同性。 这允许通过在每个持有该token的地址向Bitcoin Cash自动支付利息或股息（如果需要的话）给令牌的每个持有者。

最后，由于比特币现金钱包已经允许任意字符串被签名，所以在钱包中的每个地址上都持有一个特定的彩色硬币，这是一个小小的扩展。 这可以用来实现每股投票。

无论您对ICO（最初的硬币产品）ponzi计划和欺诈产品最近的争议的看法如何，彩色硬币都提供了有价值的功能，可以有益地被合法产品使用，最终还包括注册证券。 事实上，所有这些特征一起消除了当前金融体系周围的许多低效率 - 结算被取消，股东注册和股息支付跟踪自动发生，股东投票简单。

目前在比特币中提出了几种形式的彩色硬币，我在本文末尾详细描述。 但是我想提出一个比特币现金彩色硬币的新实现，可以通过向客户添加一个操作码来实现，与现有的建议相比具有优势。

与其他人相比，这个建议的基本“杀手级应用”优势在于它允许SPV钱包（电话钱包）使用与 SPV 钱包处理比特币相同的安全模型和机制来处理代表性令牌。

## OP_GROUP彩色硬币

OP_GROUP彩色硬币允许将资产直接表示为satoshis，并将彩色硬币转移和验证嵌入到比特币脚本语言中，使彩色硬币能够充分利用脚本，并且使得它们非常易于在现有比特币现金中实施。

新的指令被添加到称为 OP_GROUP 的脚本语言中。 当遇到 OP_GROUP 指令时，它使用堆栈顶部的数据作为组标识符，并将该输入/输出的值加到/减去与该组相关联的整数（初始化为零）。 这个整数被称为“组平衡”。 如果没有OP_GROUP，则输入/输出被假定为默认的“比特币现金”组。 在交易处理结束时，除了“比特币现金”组，其输入可能超过其输出以形成交易费（如今所发生的）之外，每个组余额必须为零。 换句话说，在每个彩色硬币组中，satoshis 花费的 satoshis 输入平衡。

基本的“有色” `pay 2 public key hash`脚本因此看起来像：

```
OP_DATA(group address)
OP_GROUP
OP_DROP
OP_DUP
OP_HASH160
OP_DATA(pubkeyhash)
OP_EQUALVERIFY
OP_CHECKSIG
```
这应该看起来很熟悉。 这就是我们今天使用的P2PKH脚本，它带有3组指令（OP_DATA，OP_GROUP和OP_DROP）。 请注意，OP_GROUP指令不会从堆栈顶部弹出组，需要后续的 OP_DRO 命令。 这很笨拙，但它允许未升级的客户端将 OP_GROUP 解释为无操作，使得在不理解 OP_GROUP（它看起来像推送数据，无操作，弹出数据...）的客户端上有效。 因此这个脚本改变不需要硬分叉。

## 创建和销毁OP_GROUP彩色硬币令牌

接下来，我们必须进行“mint”和“burn”操作，这些操作是组内输入和输出总和必须为零的规则的**例外**。 幸运的是，我们还没有定义数据的格式是一个组。 所以让我们定义一个组标识符作为ECDSA公钥的hash160（换句话说，一个比特币地址）。 这将允许我们创建一个优雅的机制，以添加和删除satoshis组。

为了将新硬币“mint”成一个组，如果一个交易有一个与 OP_GROUP 标识符相同的比特币地址签名的输入，那么该输入的值可以放在组中或比特币组中（或部分 在每个）再输出。 此外，第一个“mint”事务可以包含一个可选的 OP_RETURN，其中包含一个简短的我们可读的名称（例如股票代码）以及详细描述该组的文档/合约的散列。 例如，一个有效的交易可以输入200个BCH satoshis位于地址ABC，输出200 ABC。

为了“melt”硬币（将它们从组中除去），我们使用相同的策略。 如果一个交易输入被分组并且由与OP_GROUP标识符相同的比特币地址签名，那么该输入的值可以被放置在组中或比特币组中（或每个中的一部分）。 例如，如果交易在地址TOK和2个输出上具有值200 TOK的输入：向任何地址支付100 TOK，向另一个地址支付100 BCH satosh，作为该交易余额。

这样，只有集体地址的所有者才能“mint”新的彩色硬币或将其“melt”回BCH。

## 一些观察
### 可判定

这种方法的一个问题是群体的可判定性。 从本质上讲，如果OP_GROUP在一个复杂的脚本内（甚至只是一个“if”语句），在交易验证时间可能不可能确定什么组硬币属于（这样做会打破著名的“停止问题”证明）。 但是图灵的结果适用于“任意程序”，所以要解决这个问题我们可以限制有效脚本的范围。 首先，我们将要求只有一个OP_GROUP存在，紧接在组标识符的数据推送之前，并且这个OP_DATA（...），OP_GROUP模式是前两个脚本指令（如上所示）。

请注意，当钱包尝试确定特定交易是否包含钱包“拥有”的硬币时，今天在比特币和比特币现金中存在确切的问题。 解决方案是限制钱包生成的脚本类型，并将节点转换为一小组模板。 钱包中包含矿工包含的任何“非标准”脚本。

由于限制有效脚本是有效的，所以今天从用户的角度来看比特币家族区块链是如何操作的，将有效的OP_GROUP脚本限制为遵循特定模板的脚本并没有很大的区别。

那么为什么把它作为一个操作码，而不是每一个输出相关的数据呢？ 首先，一个操作码可以很容易地与比特币现金的交易格式集成在一起，然后我们放开一些门来放松一些限制 - 如果出现用例，可以添加新的OP_GROUP事务模板。 例如，我们可以添加一个模板，如果在“if！X”语句中存在另外一个包含OP_GROUP的输出，该模板允许在“if X”语句中指定OP_GROUP。

### 硬分叉，软分叉，没有分叉？

请注意，OP_GROUP彩色硬币即使没有硬分叉或软分叉也可能发生 - 我们需要的是一个矿工不拒绝这些交易为“非标准”。

但是，这意味着非法的OP_GROUP交易（输入不平衡每个组的输出）可以被接受非标准交易的矿工添加到区块链，但是将OP_GROUP解释为空操作。 在这种情况下，可以简单地定义在非法群体交易中每个输出上的着色消失，并且具有工作系统。 这种“强硬”操作模式与其他有色硬币建议类似（总结如下）。

但是我相信软叉是非常重要的，所以比特币现金矿工们可以执行正确的OP_GROUP语义，以确保着色不会意外丢失。 没有人愿意因为他们不小心使用了一个旧钱包，就将Google的股份作为一双satoshis发给某人！

我认为，由于区块链软件的维护人员意外失色，缺乏商定的标准，交易空间供应问题，以及彩色硬币没有“承诺”的意识，已经阻止了人们使用彩色 硬币。 相反，他们选择使用像以太坊这样的区块链，全心全意地包含多种标记类型。 然而，软分叉解决了所有这些问题。

### 为什么不使用以太坊

我相信有一个代表性的令牌只允许有限的脚本功能的地方。 以太坊脚本中出现了一些高可见性的bug，导致了利益相关者的重大价值损失。 如果一个标记不需要以太坊图灵完整语言的权力，那么这个权力就成了一个负担。

## 总结
与下面描述的其他方法相比，OP_GROUP方法的缺点是在每个彩色硬币输出总共有22个字节中增加了额外的OP_GROUP数据，尽管应该可以通过使用链参数（chainref）将其压缩到几个字节 当然，“正常”的比特币现金产出与今天看起来完全一样，因此不需要额外的空间）。 优点是：

* light 和SPV钱包的支持
* 现有比特币脚本翻译的最小改动
* 明确的和本地的令牌/颜色指定（其他建议需要知道硬币历史来确定颜色，这就是为什么他们能够更有效地编码输出）
* 矿工强制执行正确性（这意味着像比特币一样，在区块链中足够深的交易可以被轻的钱包假定为正确的）
* 仅限于一种颜色的输出
* 与脚本语言整合
* 以及为匿名P2P交换使用半事务的能力

## EPOBC
项目地址:[https://github.com/chromaway/ngcccbase/wiki/EPOBC_simple](https://github.com/chromaway/ngcccbase/wiki/EPOBC_simple)
这个系统使用satoshis作为代表性的钱币，所以基本的比特币功能和脚本是可能的。 但是，矿工不强制彩色硬币的语义。 这意味着从彩色硬币的角度来看，有可能犯下不明确或不正确的交易。 在这些情况下，协议将着色定义为“丢失”，这是主要的缺点。

输入颜色通过此处描述的基于订单的方案分配给输出。 实质上，所有的输入satoshis排列，并按照它们出现的顺序用颜色标记。 接下来，所有的输出都与输入对齐，颜色从输入satoshi传输到1输出。 该算法导致一些复杂性; 首先，一个输出可能包含不同的标记，颜色不同（例如，如果前两个输入是每500个satoshis，红色和蓝色，第一个输出是1000 satoshis，那么输出的颜色将是红色和蓝色）。 必须记住每种颜色的数量和输出中的颜色顺序。 为了确定着色，必须将所有交易追溯到颜色成因，使得轻的钱包非常难以实施）。

最后，严格的颜色排序使得使用半交易进行投标是不可能的，因为不能用第一次输入“红色”颜色和第一次输出“蓝色”颜色来创建部分交易。

但是这个协议比我的建议更有效地编码着色，因为它在区块链历史中每个硬币只编码一次着色。

## Colu 彩色硬币
项目地址:[https://github.com/Colored-Coins/Colored-Coins-Protocol-Specification/wiki](https://github.com/Colored-Coins/Colored-Coins-Protocol-Specification/wiki)
Colu彩色硬币协议不指定satoshis作为代表性货币。 它在放置在交易的OP_RETURN数据字段中的任意数据中创建独立的代表性货币令牌。 该数据包含将特定数量的多个资产从特定输入转移到特定输出的指令。 所以比特币从输入到输出的正常转移通过任意颜色量的转移而得到增强。

由于比特币矿工忽略了OP_RETURN数据字段，因此在交易中包含任意数据（例如，花费您不拥有的彩色硬币）似乎是可能的。 充其量，这些交易只能被Colu Colored Coins客户忽略，导致区块链中潜在的大量伪造数据，并增加客户错误的可能性。

由于系统不使用satoshis作为代表性货币，所以比特币脚本，签名验证等都不适用。它似乎真的是一个完全独立的系统驮在比特币区块链上。

检查位于这里的转移指令，似乎被转移的资产是隐含在已知的投入资产和他们的订单。 这不能通过查看区块链历史上的先前支出来确定，您需要追溯自资产创建以来的整个支出历史记录。 然而，“轻客户”和SPV钱包将不会有这样的历史，所以创建这种类型的客户端可能是困难的。

但是通过位于比特币区块链上，Colu彩色币可以与比特币原子交换

## 引用

原文链接：[Bitcoin Cash Scripting Applications](https://medium.com/@g.andrew.stone/bitcoin-scripting-applications-representative-tokens-ece42de81285)

***
本文由 `Copernicus 团队 冉小龙` 翻译，转载无需授权。


